<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="LuaView SDK第二版设计插件化理解(二) 第一篇提到了MILExporter类，及它的相关的Api，下面看一下它里面的具体实现。1234567891011121314151617181920212223- (void)reg:(lua_State *)L clazz:(const char *)clazzName constructor:(const char *)constructorN">
<meta property="og:type" content="article">
<meta property="og:title" content="LuaSDK插件化设计二">
<meta property="og:url" content="http://davidwang.club/2018/05/29/LuaSDK插件化设计二/index.html">
<meta property="og:site_name" content="David&#39;s blogs">
<meta property="og:description" content="LuaView SDK第二版设计插件化理解(二) 第一篇提到了MILExporter类，及它的相关的Api，下面看一下它里面的具体实现。1234567891011121314151617181920212223- (void)reg:(lua_State *)L clazz:(const char *)clazzName constructor:(const char *)constructorN">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-05-29T13:28:53.415Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LuaSDK插件化设计二">
<meta name="twitter:description" content="LuaView SDK第二版设计插件化理解(二) 第一篇提到了MILExporter类，及它的相关的Api，下面看一下它里面的具体实现。1234567891011121314151617181920212223- (void)reg:(lua_State *)L clazz:(const char *)clazzName constructor:(const char *)constructorN">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://davidwang.club/2018/05/29/LuaSDK插件化设计二/"/>





  <title>LuaSDK插件化设计二 | David's blogs</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">David's blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-search">
          <a href="/search" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            搜索
          </a>
        </li>
      
        
        <li class="menu-item menu-item-something">
          <a href="/something" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            something
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://davidwang.club/2018/05/29/LuaSDK插件化设计二/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="David">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/image/logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="David's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">LuaSDK插件化设计二</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-29T21:26:58+08:00">
                2018-05-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>LuaView SDK第二版设计插件化理解(二)</p>
<p>第一篇提到了MILExporter类，及它的相关的Api，下面看一下它里面的具体实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (void)reg:(lua_State *)L clazz:(const char *)clazzName constructor:(const char *)constructorName cfunc:(lua_CFunction)cfunc name:(const char *)luaName 注册key到Lua虚拟机的全局表。 传入了className,constructorName。以className为key，具体的闭包为value进行写入。具体代码如下。</span><br><span class="line">      	+ (void)reg:(lua_State *)L clazz:(const char *)clazzName constructor:(const char *)constructorName cfunc:(lua_CFunction)cfunc name:(const char *)luaName</span><br><span class="line">      </span><br><span class="line">      &#123;</span><br><span class="line">      </span><br><span class="line">          NSAssert(mm_CharPointIsNotNULL(clazzName), @&quot;The class must not be nil!&quot;);</span><br><span class="line">      </span><br><span class="line">          NSAssert(mm_CharPointIsNotNULL(luaName), @&quot;The lua name of class must not be nil!&quot;);</span><br><span class="line">      </span><br><span class="line">          lua_checkstack(L, 12);</span><br><span class="line">         </span><br><span class="line">          // 把native类名压栈</span><br><span class="line">          lua_pushstring(L, clazzName);</span><br><span class="line">          // 是否为属性压栈。这个暂时没用到</span><br><span class="line">          lua_pushboolean(L, NO); // 不是属性</span><br><span class="line">          // 把初始化方法名称压栈。如果没有的话则走默认的</span><br><span class="line">          lua_pushstring(L, mm_CharPointIsNotNULL(constructorName) ? constructorName : &quot;init&quot;);</span><br><span class="line">          // 设置closure的upValue 出栈相应的元素，闭包压栈</span><br><span class="line">          lua_pushcclosure(L, cfunc, 3);</span><br><span class="line">           // 设置闭包到全局表</span><br><span class="line">          lua_setglobal(L, luaName);</span><br><span class="line">      </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>这个文件的一个核心函数。void mm_lua_openlib (lua_State <em>L, const char </em>libname,                     const struct mm_lua_objc_method *l, int nup) {  注册实例方法到元表和注册类方法到类对应的表。</p>
<pre><code>void mm_lua_openlib (lua_State *L, const char *libname,
                     const struct mm_lua_objc_method *l, int nup) {
    // 如果libname存在。则相当于注册类方法。
    if (libname) {
        int size = mm_libsize(l);
        /* check whether lib already exists */
        luaL_findtable(L, LUA_REGISTRYINDEX, &quot;_LOADED&quot;, 1);
        lua_getfield(L, -1, libname);  /* get _LOADED[libname] */
        if (!lua_istable(L, -1)) {  /* not found? */
            lua_pop(L, 1);  /* remove previous result */
            /* try global variable (and create one if it does not exist) */
            if (luaL_findtable(L, LUA_GLOBALSINDEX, libname, size) != NULL)
                luaL_error(L, &quot;name conflict for module &quot; LUA_QS, libname);
            lua_pushvalue(L, -1);
            lua_setfield(L, -3, libname);  /* _LOADED[libname] = new table */
        }
        lua_remove(L, -2);  /* remove _LOADED table */
        lua_insert(L, -(nup+1));  /* move library table to below upvalues */
    }
    // 上面的过程相当于在LUA_GLOBALSINDEX 表中获取libname对应的表
    for (; l-&gt;l_mn; l++) {
        NSCAssert(mm_CharPointIsNotNULL(l-&gt;clz), @&quot;The class name must not be nil!&quot;);
        NSCAssert(l-&gt;func!=NULL, @&quot;The C function must not be NULL!&quot;);
        int extraCount = 0;
        // 类名压栈
        lua_pushstring(L, l-&gt;clz); // class
        // bool 属性压栈
        lua_pushboolean(L, l-&gt;isProperty);
        if (l-&gt;isProperty) {
            NSCAssert(mm_CharPointIsNotNULL(l-&gt;setter_n), @&quot;The method name must not be nil!&quot;);        // 为属性则setter_n和getter_n 字符串压栈
            lua_pushstring(L, l-&gt;setter_n); // setter
            NSCAssert(mm_CharPointIsNotNULL(l-&gt;getter_n), @&quot;The method name must not be nil!&quot;);
            lua_pushstring(L, l-&gt;getter_n); // getter
            extraCount = 4;
        } else {
            NSCAssert(mm_CharPointIsNotNULL(l-&gt;mn), @&quot;The method name must not be nil!&quot;);      
            //否则则 selector名称压栈
            lua_pushstring(L, l-&gt;mn); // selector
            extraCount = 3;
        }
        int i;
        for (i=0; i&lt;nup; i++)  /* copy upvalues to the top */
            lua_pushvalue(L, -(nup+extraCount));
        // 将相应数量的元素 出栈 +  存储上面压栈的值 +  相应的闭包压栈 +
        lua_pushcclosure(L, l-&gt;func, (nup+extraCount));
        // 找到 -(nup+2) 这个位置上面的表，设置l-&gt;l_mn为key,栈顶元素为value 写入表。
        lua_setfield(L, -(nup+2), l-&gt;l_mn);
    }
    // 栈中移除相应数量的元素
    lua_pop(L, nup);  /* remove upvalues */
}
</code></pre></li>
</ul>
<p>   下面来看下非常核心的Lua与native的通讯部分，刘旭对原来的通讯方式进行完全的改变。这是LuaViewSDK优化最核心的部分。</p>
<ul>
<li>上面一直提到我们自己构建了结构体对象。我们映射到Lua的只是这个结构体，映射到lua的全部类方法和对象方法都可以通过这个结构体的MMLua_Method 表示。Lua 去掉用userdata方法，原本通过各个单独的方法调用，现在改为全部都路由到一个C的Api里面，然后在这个Api里面进行消息的分发。下面看下具体的结构体。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">struct mm_lua_objc_method ;</span><br><span class="line">typedef struct mm_lua_objc_method *MMLua_Method;</span><br><span class="line">struct mm_lua_objc_class;</span><br><span class="line">typedef struct mm_lua_objc_class *MMLua_Class;</span><br><span class="line"></span><br><span class="line">typedef struct mm_lua_objc_method&#123;</span><br><span class="line">    const char *l_mn;      /* Object-C method name in lua*/</span><br><span class="line">    const char *mn;       /* Object-C method name */</span><br><span class="line">    const char *clz;      /* Object-C class name */</span><br><span class="line">    BOOL isProperty;      /* It&apos;s YES if property method*/</span><br><span class="line">    const char *setter_n;   /* Object-C getter method name*/</span><br><span class="line">    const char *getter_n;   /* Object-C setter method name */</span><br><span class="line">    lua_CFunction func;     // 元表对应的func。注册进去的都是func。</span><br><span class="line">&#125;mm_lua_objc_method;</span><br><span class="line"></span><br><span class="line">typedef struct mm_lua_objc_class&#123;</span><br><span class="line">    const  char *pkg;  // package name </span><br><span class="line">    const  char *clz;  // 类名</span><br><span class="line">    const  char *l_clz;  ///* Object-C class name in lua */</span><br><span class="line">    const char *l_type; /* its type of Object-C class in lua  */</span><br><span class="line">    BOOL isRoot; /* is root function,it should be YES if no base class. */</span><br><span class="line">    const char *supreClz; /* base Object-C class */</span><br><span class="line">    BOOL hasConstructor; /* it should be NO if static class. */</span><br><span class="line">    MMLua_Method methods; /* Object-C method */</span><br><span class="line">    MMLua_Method clz_methods; /* Object-C class method */</span><br><span class="line">    // 初始化函数的描述</span><br><span class="line">    struct mm_lua_objc_method constructor; /* Object-C constructor method */</span><br><span class="line">    </span><br><span class="line">&#125;mm_lua_objc_class;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>下面以 LUA_EXPORT_VIEW_PROPERTY(image, “lua_setImage:”, “lua_image”, MMGraphicButton) 为例。看下具体这个宏定义为我们做了什么。连续点击进去可以发现这个宏最终会我们生成mm_lua_objc_method 这个结构体的一个实例。{image,NULL,MMGraphicButton,YES,”lua_setImage”,”lua_image”,mm_lua_router_method};</p>
<ul>
<li><p>此时我们再去查看发现所有的Lua去调用对象方法实际都会路由到我们的mm_lua_router_method中，然后通过这个方法再去生成相应的Invocation 进行invoke调用。我们来具体看下mm_lua_router_method具体做了什么。</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  int mm_lua_router_method (lua_State *L) {</p>
<pre><code>NSCAssert(L, @&quot;The lua state must not be null!&quot;);
// class 首先获取Class
Class clazz = mm_lua_resolveClass(L);
// 同理在closure的上值中获取是否为Property
BOOL isProperty = mm_lua_resolveIsProperty(L);
// 获取SEL。 如果非属性则直接在上值中获取Sel名称转为SEL
SEL selector = isProperty ? mm_lua_resolveGetterOrSetter(L) : mm_lua_resolveSelector(L);
// 方法的调用。
return mm_lua_call_objc_method(L, selector, clazz);
</code></pre><p>  }</p>
<p>  Class mm_lua_resolveClass (lua_State *L) {</p>
<pre><code>NSCAssert(L, @&quot;The lua state must not be null!&quot;);
NSCAssert(lua_isstring(L, lua_upvalueindex(1)), @&quot;The first upvalue must be a string of class name!&quot;);
// 通过伪索引 去获取Closure中的上值。
NSString *clazzString = [NSString stringWithUTF8String:lua_tostring(L, lua_upvalueindex(1))];
NSCAssert(clazzString &amp;&amp; clazzString.length &gt; 0, @&quot;The class name must not be nil!&quot;);
// 将上值存储的string转成Class。上面的openLib方法涉及到了上值的存储。会存储到生成的Closure的upValue数组中。具体的闭包调用的时候在Lua虚拟机的ci的func拿到func，此时为TValue对象，通过TValue找到Closure。
return NSClassFromString(clazzString);
</code></pre><p>  }<br>  // 在上值中获取是否为Property.<br>  BOOL mm_lua_resolveIsProperty (lua_State *L) {</p>
<pre><code>NSCAssert(L, @&quot;The lua state must not be null!&quot;);
NSCAssert(lua_isboolean(L, lua_upvalueindex(2)), @&quot;The first upvalue must be a string of selector name!&quot;);
return lua_toboolean(L, lua_upvalueindex(2));
</code></pre><p>  }<br>  //  同理通过Lua栈中参数的个数获取是get还是set方法。然后通过上值将String转成Selector<br>  SEL mm_lua_resolveGetterOrSetter (lua_State *L) {</p>
<pre><code>NSCAssert(L, @&quot;The lua state must not be null!&quot;);
int selIdx = [MILExporter isLuaCallGetter:L] ? 4 : 3; // setter&apos;s index is 3, getter&apos;s index is 4
return mm_lua_resolveSelectorAtIndex(L, selIdx);
</code></pre><p>  }</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 上面提到了mm_lua_call_objc_method 下面来看下到底做了什么。</span><br></pre></td></tr></table></figure>
<p>  int mm_lua_call_objc_method (lua_State *L, SEL selector, Class<milentityclassprotocol> clazz) {</milentityclassprotocol></p>
<pre><code>NSCAssert(L, @&quot;The lua state must not be null!&quot;);
// 在栈底获取Userdata对象并进行类型判断。返回userdata-&gt;object对象
id targetObj = [MILExporter targetOnLuaCall:L class:clazz];
// 重置LuaCore
mm_lua_resetLuaCore(L, clazz);
// 进行真实的方法的调用。
return mm_lua_call_objc(L, targetObj, selector, NO);
</code></pre><p>  }</p>
<p>  /*</p>
<pre><code>1. 通过SEL获取方法签名
2. 通过方法签名生成NSInvocation
3. 设置Invocation的SEL,target,参数
4. 执行invocation的invoke的操作
5. 通过invocation的returnType 确定返回值的个数
</code></pre><p>  *<em>/<br>  int mm_lua_call_objc (lua_State </em>L, id target, SEL selector, BOOL isclass) {</p>
<pre><code>NSCAssert(L, @&quot;The lua state must not be null!&quot;);
NSCAssert(target, @&quot;The target must not be nil!&quot;);
// 获取方法前面通过SEL
NSMethodSignature *sig = [target methodSignatureForSelector:selector];
// 确定方法前面中参数的个数
NSUInteger argsCount = [sig numberOfArguments] - 2;
// Lua堆栈中个数
int l_argsCount = [MILExporter numOfArgsOnLuaCallIn:L];
</code></pre><p>  //    NSCAssert(argsCount==l_argsCount, @”The number of parameters does not match！”);</p>
<pre><code>// 通过方法签名生成NSInvocation 对象
NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:sig];
// 设置target
[invocation setTarget:target];
// 设置SEL
[invocation setSelector:selector];
// 后续是参数的设置
NSMutableArray *retainArray = [NSMutableArray arrayWithCapacity:argsCount];
// retain invocation中的target和参数
[invocation retainArguments];
for (int i = 2; i &lt;= argsCount + 1; i++) {
    int argIdx = i;
    int stackIdx = i;
    MMTypeConvertorErr success = mm_setInvocationArgByLua(invocation, argIdx, L, stackIdx, retainArray, !isclass);
    switch (success) {
        case MMTypeConvertorUndef:
            lua_settop(L, 0);
            lua_pushstring(L, &quot;Undefined parameter type&quot;);
            return 1;
        case MMTypeConvertorTypeErr:
             lua_settop(L, 0);
            lua_pushstring(L, &quot;An error occurred about the parameter type&quot;);
            return 1;
        default:
            break;
    }
}
// invocation的调用。
[invocation invoke];
return mm_pushInvocationReturnToLua(invocation, L);
</code></pre><p>  }</p>
<p>  // 下面具体看一下setArgument: atIndex:的过程</p>
<p>  int mm_setInvocationArgByLua(NSInvocation <em>invocation, int index, lua_State </em>L, int stackID, NSMutableArray *retainArray, BOOL hasTarger4Block) {</p>
<pre><code>// 通过方法前面获取指定位置参数的描述const char* 
const char* type = [invocation.methodSignature getArgumentTypeAtIndex:index];
if (type){
    switch (mm_typeOfObjc(type)) {
        case MM_OBJCType_BOOL: {
            // Lua 栈相应位置拿到值
            BOOL value = lua_toboolean(L, stackID);
            // 设置到invocation相应的位置
            [invocation setArgument:&amp;value atIndex:index];
            return 0;
        }
        case MM_OBJCType_class: {
            if (lua_isstring(L, stackID)) {
                Class clazz = NSClassFromString(lv_paramString(L, stackID));
                [invocation setArgument:&amp;clazz atIndex:index];
            }
            return 0;
        }
        case MM_OBJCType_block: {
            if (lua_isfunction(L, stackID)) {
                MILBlock *block = nil;
                if (hasTarger4Block) {
                    block = [[MILBlock alloc] initWithTarget:invocation.target luaCore:LV_LUASTATE_VIEW(L) index:stackID];
                } else {
                    block = [[MILBlock alloc] initWithLuaCore:LV_LUASTATE_VIEW(L) index:stackID];
                }
                MILCallback callback = [^(id result, BOOL keepAlive){
                    [block callWithParam:result];
                } copy];
                [retainArray addObject:callback];
                // 设置callback到指定位置
                [invocation setArgument:&amp;callback atIndex:index];
            }
            return 0;
        }
        case MM_OBJCType_SEL: {
            if (lua_isstring(L, stackID)) {
                SEL selector = NSSelectorFromString(lv_paramString(L, stackID));
                [invocation setArgument:&amp;selector atIndex:index];
            }
            return 0;
        }
        case MM_OBJCType_id: {
            id nativeObject = nil;
            if (hasTarger4Block) {
                // lua对象转native对象
                nativeObject = mm_lua_tonativeobj(L, stackID, invocation.target);
            } else {
                nativeObject = mm_lua_tonativeobj(L, stackID, nil);
            }
            [invocation setArgument:&amp;nativeObject atIndex:index];
            return 0;
        }
        case MM_OBJCType_char: {
            char value = lua_tonumber(L, stackID);
            [invocation setArgument:&amp;value atIndex:index];
            return 0;
        }
        case MM_OBJCType_uchar: {
            unsigned char value = lua_tonumber(L, stackID);
            [invocation setArgument:&amp;value atIndex:index];
            return 0;
        }
        case MM_OBJCType_short: {
            short value = lua_tonumber(L, stackID);
            [invocation setArgument:&amp;value atIndex:index];
            return 0;
        }
        case MM_OBJCType_ushort: {
            unsigned short value = lua_tonumber(L, stackID);
            [invocation setArgument:&amp;value atIndex:index];
            return 0;
        }
        case MM_OBJCType_int: {
            int value = lua_tonumber(L, stackID);
            [invocation setArgument:&amp;value atIndex:index];
            return 0;
        }
        case MM_OBJCType_uint: {
            unsigned int value = lua_tonumber(L, stackID);
            [invocation setArgument:&amp;value atIndex:index];
            return 0;
        }
        case MM_OBJCType_long: {
            long value = lua_tonumber(L, stackID);
            [invocation setArgument:&amp;value atIndex:index];
            return 0;
        }
        case MM_OBJCType_ulong: {
            unsigned long value = lua_tonumber(L, stackID);
            [invocation setArgument:&amp;value atIndex:index];
            return 0;
        }
        case MM_OBJCType_llong: {
            long long value = lua_tonumber(L, stackID);
            [invocation setArgument:&amp;value atIndex:index];
            return 0;
        }
        case MM_OBJCType_ullong: {
            unsigned long long value = lua_tonumber(L, stackID);
            [invocation setArgument:&amp;value atIndex:index];
            return 0;
        }
        case MM_OBJCType_float: {
            float value = lua_tonumber(L, stackID);
            [invocation setArgument:&amp;value atIndex:index];
            return 0;
        }
        case MM_OBJCType_double: {
            double value = lua_tonumber(L, stackID);
            [invocation setArgument:&amp;value atIndex:index];
            return 0;
        }
        case MM_OBJCType_char_ptr: {
            char *value = lua_touserdata(L, stackID);
            [invocation setArgument:&amp;value atIndex:index];
            return 0;
        }
        case MM_OBJCType_void_ptr: {
            void *value = lua_touserdata(L, stackID);
            [invocation setArgument:&amp;value atIndex:index];
            return 0;
        }
        case MM_OBJCType_const_char_ptr: {
            const char *value = lua_touserdata(L, stackID);
            [invocation setArgument:&amp;value atIndex:index];
            return 0;
        }
        case MM_OBJCType_rect: {
            CGRect orig_rect = mm_lua_tocgrect(L, stackID);
            [invocation setArgument:&amp;orig_rect atIndex:index];
            return 0;
        }
        case MM_OBJCType_size: {
            CGSize orig_size = mm_lua_tocgsize(L, stackID);
            [invocation setArgument:&amp;orig_size atIndex:index];
            return 0;
        }
        case MM_OBJCType_point: {
            CGPoint orig_point = mm_lua_tocgpoint(L, stackID);
            [invocation setArgument:&amp;orig_point atIndex:index];
            return 0;
        }
        default: {
            NSInteger value = 0;
            NSCAssert(value, @&quot;Undefined parameter type！&quot;);
            [invocation setArgument: &amp;value atIndex:index];
            LVError(@&quot;Undefined parameter type！&quot;);
            return 1; // 参数类型不支持
        }
    }
}
NSCAssert(NO, @&quot;An error occurred about the parameter type！&quot;);
return 2; // 获取参数类型失败
</code></pre><p>  }</p>
<p>  /*<em><br>   获取oc数据类型 mm_typeOfObjc
   </em>/<br>  MM_Objc_Type mm_typeOfObjc(const char *type) {</p>
<pre><code>switch (type[0]) {
        // id类型
    case _C_ID: //#define _C_ID       &apos;@&apos;
        // 则返回Block
        if (type[1] == _C_UNDEF) {    &apos;？&apos;
            return MM_OBJCType_block;
        }
        return MM_OBJCType_id;
    case _C_CLASS: //#define _C_CLASS    &apos;#&apos;
        return MM_OBJCType_class;
    case _C_SEL:  //#define _C_SEL      &apos;:&apos;
        return MM_OBJCType_SEL;
    case _C_CHR:  //#define _C_CHR      &apos;c&apos;
        return MM_OBJCType_char;
    case _C_UCHR: //#define _C_UCHR     &apos;C&apos;
        return MM_OBJCType_uchar;
    case _C_SHT:  //#define _C_SHT      &apos;s&apos;
        return MM_OBJCType_short;
    case _C_USHT: //#define _C_USHT     &apos;S&apos;
        return MM_OBJCType_ushort;
    case _C_INT:  //#define _C_INT      &apos;i&apos;
        return MM_OBJCType_int;
    case _C_UINT: //#define _C_UINT     &apos;I&apos;
        return MM_OBJCType_uint;
    case _C_LNG:  //#define _C_LNG      &apos;l&apos;
        return MM_OBJCType_long;
    case _C_ULNG: //#define _C_ULNG     &apos;L&apos;
        return MM_OBJCType_ulong;
    case _C_LNG_LNG: //#define _C_LNG_LNG  &apos;q&apos;
        return MM_OBJCType_llong;
    case _C_ULNG_LNG: //#define _C_ULNG_LNG &apos;Q&apos;
        return MM_OBJCType_ullong;
    case _C_FLT: //#define _C_FLT      &apos;f&apos;
        return MM_OBJCType_float;
    case _C_DBL: //#define _C_DBL      &apos;d&apos;
        return MM_OBJCType_double;
    case _C_BOOL: //#define _C_BOOL     &apos;B&apos;
        return MM_OBJCType_BOOL;
    case _C_VOID: //#define _C_VOID     &apos;v&apos;
        return MM_OBJCType_void;
    case _C_CHARPTR: //#define _C_CHARPTR  &apos;*&apos;
        return MM_OBJCType_char_ptr;
    case _C_STRUCT_B: { //#define _C_STRUCT_B &apos;{&apos; 结构体
        // #define mm_strcmp(a, b) (strcmp((a), (b)) == 0)
        if (mm_strcmp(type, @encode(CGRect))) {
            return MM_OBJCType_rect;
        } else if (mm_strcmp(type, @encode(CGSize))) {
            return MM_OBJCType_size;
        } else if (mm_strcmp(type, @encode(CGPoint))) {
            return MM_OBJCType_point;
        }
        return MM_OBJCType_struct;
    }
    case _C_PTR: { //#define _C_PTR      &apos;^&apos;
        if (type[1] == _C_ID) { ? 
            return MM_OBJCType_id_ptr;
        }  else if (type[1] == _C_STRUCT_B) {
            return MM_OBJCType_struct_ptr;
        }  else if (mm_strcmp(type, @encode(void *))) {
            return MM_OBJCType_void_ptr;
        }
        //TODO: 待支持其他类型
        return MM_OBJCType_ndef;
    }
    case _C_CONST: { //#define _C_CONST    &apos;r&apos; 常量
        if (mm_strcmp(type, @encode(const char *))) {
            return MM_OBJCType_const_char_ptr;
        }
        //TODO: 待支持其他类型
        return MM_OBJCType_ndef;
    }
    default:  //#define _C_UNDEF    &apos;?&apos;
        return MM_OBJCType_ndef;
}
</code></pre><p>  }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">上面提到的各种type_VOID等 实际对应了一张表在runtime.h中。对应了所有的参数的类型对应的字符串</span><br><span class="line"></span><br><span class="line">    #define _C_ID       &apos;@&apos;</span><br><span class="line">    #define _C_CLASS    &apos;#&apos;</span><br><span class="line">    #define _C_SEL      &apos;:&apos;</span><br><span class="line">    #define _C_CHR      &apos;c&apos;</span><br><span class="line">    #define _C_UCHR     &apos;C&apos;</span><br><span class="line">    #define _C_SHT      &apos;s&apos;</span><br><span class="line">    #define _C_USHT     &apos;S&apos;</span><br><span class="line">    #define _C_INT      &apos;i&apos;</span><br><span class="line">    #define _C_UINT     &apos;I&apos;</span><br><span class="line">    #define _C_LNG      &apos;l&apos;</span><br><span class="line">    #define _C_ULNG     &apos;L&apos;</span><br><span class="line">    #define _C_LNG_LNG  &apos;q&apos;</span><br><span class="line">    #define _C_ULNG_LNG &apos;Q&apos;</span><br><span class="line">    #define _C_FLT      &apos;f&apos;</span><br><span class="line">    #define _C_DBL      &apos;d&apos;</span><br><span class="line">    #define _C_BFLD     &apos;b&apos;</span><br><span class="line">    #define _C_BOOL     &apos;B&apos;</span><br><span class="line">    #define _C_VOID     &apos;v&apos;</span><br><span class="line">    #define _C_UNDEF    &apos;?&apos;</span><br><span class="line">    #define _C_PTR      &apos;^&apos;</span><br><span class="line">    #define _C_CHARPTR  &apos;*&apos;</span><br><span class="line">    #define _C_ATOM     &apos;%&apos;</span><br><span class="line">    #define _C_ARY_B    &apos;[&apos;</span><br><span class="line">    #define _C_ARY_E    &apos;]&apos;</span><br><span class="line">    #define _C_UNION_B  &apos;(&apos;</span><br><span class="line">    #define _C_UNION_E  &apos;)&apos;</span><br><span class="line">    #define _C_STRUCT_B &apos;&#123;&apos;</span><br><span class="line">    #define _C_STRUCT_E &apos;&#125;&apos;</span><br><span class="line">    #define _C_VECTOR   &apos;!&apos;</span><br><span class="line">    #define _C_CONST    &apos;r&apos;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">下面看下Lua端调用以上方法返回部分。也就是调用方法后，相应的native对象需要转为相应的lua支持的对象压栈。</span><br><span class="line"></span><br><span class="line">    int mm_pushInvocationReturnToLua(NSInvocation* invocation, lua_State* L) &#123;</span><br><span class="line">        // 通过方法签名拿到返回参数的字符串描述</span><br><span class="line">        const char *type = [invocation.methodSignature methodReturnType];</span><br><span class="line">        if (type)&#123;</span><br><span class="line">            // 上面已经说了。具体看上面runtime的一个表去对应</span><br><span class="line">            switch (mm_typeOfObjc(type)) &#123;</span><br><span class="line">                case MM_OBJCType_void:</span><br><span class="line">                    return 0;</span><br><span class="line">                case MM_OBJCType_BOOL: &#123;</span><br><span class="line">                    BOOL result = 0;</span><br><span class="line">                    // 传入参数的地址。方法内部会根据传入的指针会修改相应内存的值</span><br><span class="line">                    [invocation getReturnValue: &amp;result];</span><br><span class="line">                    lua_pushboolean(L, result);</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125;</span><br><span class="line">                case MM_OBJCType_class: &#123;</span><br><span class="line">                    Class clazz = nil;</span><br><span class="line">                    [invocation getReturnValue:&amp;clazz];</span><br><span class="line">                    if (clazz) &#123;</span><br><span class="line">                        lua_pushstring(L, NSStringFromClass(clazz).UTF8String);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        lua_pushnil(L);</span><br><span class="line">                    &#125;</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125;</span><br><span class="line">                case MM_OBJCType_SEL: &#123;</span><br><span class="line">                    SEL sel = nil;</span><br><span class="line">                    [invocation getReturnValue:&amp;sel];</span><br><span class="line">                    if (sel) &#123;</span><br><span class="line">                        lua_pushstring(L, NSStringFromSelector(sel).UTF8String);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        lua_pushnil(L);</span><br><span class="line">                    &#125;</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125;</span><br><span class="line">                case MM_OBJCType_id: &#123;</span><br><span class="line">                    void *result = nil;</span><br><span class="line">                    [invocation getReturnValue:&amp;result];</span><br><span class="line">                    mm_lua_pushnativeobj(L,(__bridge id)result);</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125;</span><br><span class="line">                case MM_OBJCType_char: &#123;</span><br><span class="line">                    char result = 0;</span><br><span class="line">                    [invocation getReturnValue: &amp;result];</span><br><span class="line">                    lua_pushnumber(L, result);</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125;</span><br><span class="line">                case MM_OBJCType_uchar: &#123;</span><br><span class="line">                    unsigned char result = 0;</span><br><span class="line">                    [invocation getReturnValue: &amp;result];</span><br><span class="line">                    lua_pushnumber(L, result);</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125;</span><br><span class="line">                case MM_OBJCType_short: &#123;</span><br><span class="line">                    short result = 0;</span><br><span class="line">                    [invocation getReturnValue: &amp;result];</span><br><span class="line">                    lua_pushnumber(L, result);</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125;</span><br><span class="line">                case MM_OBJCType_ushort: &#123;</span><br><span class="line">                    unsigned short result = 0;</span><br><span class="line">                    [invocation getReturnValue: &amp;result];</span><br><span class="line">                    lua_pushnumber(L, result);</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125;</span><br><span class="line">                case MM_OBJCType_int: &#123;</span><br><span class="line">                    int result = 0;</span><br><span class="line">                    [invocation getReturnValue: &amp;result];</span><br><span class="line">                    lua_pushnumber(L, result);</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125;</span><br><span class="line">                case MM_OBJCType_uint: &#123;</span><br><span class="line">                    unsigned int result = 0;</span><br><span class="line">                    [invocation getReturnValue: &amp;result];</span><br><span class="line">                    lua_pushnumber(L, result);</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125;</span><br><span class="line">                case MM_OBJCType_long: &#123;</span><br><span class="line">                    long result = 0;</span><br><span class="line">                    [invocation getReturnValue: &amp;result];</span><br><span class="line">                    lua_pushnumber(L, result);</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125;</span><br><span class="line">                case MM_OBJCType_ulong: &#123;</span><br><span class="line">                    unsigned long result = 0;</span><br><span class="line">                    [invocation getReturnValue: &amp;result];</span><br><span class="line">                    lua_pushnumber(L, result);</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125;</span><br><span class="line">                case MM_OBJCType_llong: &#123;</span><br><span class="line">                    long long result = 0;</span><br><span class="line">                    [invocation getReturnValue: &amp;result];</span><br><span class="line">                    lua_pushnumber(L, result);</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125;</span><br><span class="line">                case MM_OBJCType_ullong: &#123;</span><br><span class="line">                    unsigned long long result = 0;</span><br><span class="line">                    [invocation getReturnValue: &amp;result];</span><br><span class="line">                    lua_pushnumber(L, result);</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125;</span><br><span class="line">                case MM_OBJCType_float: &#123;</span><br><span class="line">                    float result = 0;</span><br><span class="line">                    [invocation getReturnValue: &amp;result];</span><br><span class="line">                    lua_pushnumber(L, result);</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125;</span><br><span class="line">                case MM_OBJCType_double: &#123;</span><br><span class="line">                    double result = 0;</span><br><span class="line">                    [invocation getReturnValue: &amp;result];</span><br><span class="line">                    lua_pushnumber(L, result);</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125;</span><br><span class="line">                case MM_OBJCType_char_ptr: &#123;</span><br><span class="line">                    char *result = 0;</span><br><span class="line">                    [invocation getReturnValue: &amp;result];</span><br><span class="line">                    lua_pushlightuserdata(L, result);</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125;</span><br><span class="line">                case MM_OBJCType_void_ptr: &#123;</span><br><span class="line">                    void *result = 0;</span><br><span class="line">                    [invocation getReturnValue: &amp;result];</span><br><span class="line">                    lua_pushlightuserdata(L, result);</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125;</span><br><span class="line">                case MM_OBJCType_rect:&#123;</span><br><span class="line">                    CGRect rect = CGRectZero;</span><br><span class="line">                    [invocation getReturnValue:&amp;rect];</span><br><span class="line">                    mm_lua_pushcgrect(L, rect);</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125;</span><br><span class="line">                case MM_OBJCType_size:&#123;</span><br><span class="line">                    CGSize size = CGSizeZero;</span><br><span class="line">                    [invocation getReturnValue:&amp;size];</span><br><span class="line">                    mm_lua_pushcgsize(L, size);</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125;</span><br><span class="line">                case MM_OBJCType_point:&#123;</span><br><span class="line">                    CGPoint point = CGPointZero;</span><br><span class="line">                    [invocation getReturnValue:&amp;point];</span><br><span class="line">                    mm_lua_pushcgpoint(L, point);</span><br><span class="line">                    return 1;</span><br><span class="line">                &#125;</span><br><span class="line">                default: &#123;</span><br><span class="line">                    NSInteger value = 0;</span><br><span class="line">                    NSCAssert(value, @&quot;Undefined parameter type！&quot;);</span><br><span class="line">                    [invocation setArgument: &amp;value atIndex:index];</span><br><span class="line">                    LVError(@&quot;Undefined parameter type！&quot;);</span><br><span class="line">                    return 0; // 参数类型不支持</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        NSCAssert(NO, @&quot;An error occurred about the parameter type！&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">上面对应每一种返回的参数类型 做了switch。在invocation中获取相应的参数。然后压入lua栈中。普通数据类型，转成Lua可以接收的类型压栈，Lua不能直接接收的id类型。并没有继续采用SDK内部的包装一个LVBox的方式。而是进行了自己的创新，把每一种具体的类型都展开。当然userdata的话转为相应的userdata并压栈。具体代码如下。</span><br><span class="line"></span><br><span class="line">    void mm_lua_pushnativeobj (lua_State* L, id value) &#123;</span><br><span class="line">        lua_checkstack(L, 4);</span><br><span class="line">        </span><br><span class="line">        if( [value isKindOfClass:[NSString class]] ) &#123;</span><br><span class="line">            NSString* s = value;</span><br><span class="line">            lua_pushstring(L, s.UTF8String);</span><br><span class="line">        &#125; else if( [value isKindOfClass:[NSDictionary class]] ) &#123;</span><br><span class="line">            NSDictionary* dictionary = value;</span><br><span class="line">            lua_newtable(L);</span><br><span class="line">            for (NSString *key in dictionary) &#123;</span><br><span class="line">                NSString* value = dictionary[key];</span><br><span class="line">                lua_checkstack(L, 4);</span><br><span class="line">                lua_pushstring(L, key.UTF8String);</span><br><span class="line">                mm_lua_pushnativeobj(L,value);</span><br><span class="line">                lua_settable(L, -3);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if( [value isKindOfClass:[NSArray class]] ) &#123;</span><br><span class="line">            NSArray* array = value;</span><br><span class="line">            lua_newtable(L);</span><br><span class="line">            for (int i=0; i&lt;array.count; i++) &#123;</span><br><span class="line">                id value = array[i];</span><br><span class="line">                lua_pushnumber(L, i+1);</span><br><span class="line">                mm_lua_pushnativeobj(L,value);</span><br><span class="line">                lua_settable(L, -3);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if( [value isKindOfClass:[NSNumber class]] ) &#123;</span><br><span class="line">            static Class boolClass = nil;;</span><br><span class="line">            if ( boolClass == nil ) &#123;</span><br><span class="line">                boolClass = [@(YES) class];</span><br><span class="line">            &#125;</span><br><span class="line">            NSNumber* number = value;</span><br><span class="line">            if( [value class] == boolClass) &#123;</span><br><span class="line">                //  是否是bool类型</span><br><span class="line">                lua_pushboolean(L, number.boolValue);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                lua_pushnumber(L, number.doubleValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  else if( value == nil || value == [NSNull null] ) &#123;</span><br><span class="line">            lua_pushnil(L);</span><br><span class="line">        &#125;  else if( value &amp;&amp; [value isKindOfClass:[UIImage class]] ) &#123;</span><br><span class="line">            // 直接使用LVBitmap。生成Bitmap包装成userdata压栈</span><br><span class="line">            mm_lua_pushnativeimage(L, value);</span><br><span class="line">        &#125;  else if( value &amp;&amp; [value isKindOfClass:[NSData class]] ) &#123;</span><br><span class="line">            // 直接使用LVData 关联真实的data</span><br><span class="line">            mm_lua_pushnativedata(L, value);</span><br><span class="line">        &#125;  else if( value &amp;&amp; [value isKindOfClass:[NSDate class]] ) &#123;</span><br><span class="line">            // 直接使用LVDate。关联真实的日期。然后将生成的userdata压栈</span><br><span class="line">            mm_lua_pushnativedate(L, value);</span><br><span class="line">        &#125; else if ([value conformsToProtocol:@protocol(MILEntityClassProtocol)])&#123;</span><br><span class="line">            NSCAssert([[value class] respondsToSelector:@selector(pluginOfLua)], @&quot;The @sel(pluginOfLua) must be responds!&quot;);</span><br><span class="line">            // 最经典的~ 。 满足相应协议的，直接通过协议拿到相应的插件，插件通过setUp根据宿主类的相关信息生成userdata 然后压栈。</span><br><span class="line">            mm_lua_pushEntity(L, (id&lt;MILEntityClassProtocol&gt;)value);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            NSCAssert(NO, @&quot;An error occurred about the parameter type！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> 返回值为Lua端在栈中获取相应参数的个数</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/28/LuaSDK插件化设计/" rel="next" title="LuaSDK插件化设计">
                <i class="fa fa-chevron-left"></i> LuaSDK插件化设计
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/image/logo.jpg"
                alt="David" />
            
              <p class="site-author-name" itemprop="name">David</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/wangning-lingli" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="wang.ning_1920@immomo.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="351723770" target="_blank" title="QQ">
                      
                        <i class="fa fa-fw fa-QQ"></i>QQ</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">David</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div style="margin:-20px;position: absolute;right:265px;">
<dl style="float:left">
  <dt style="float:left">
    <dd style="float:left;width:300px">
      <span style="float:right">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|</span>
      <span style="float:right">本站总访问量<span><span style="float:right" id="busuanzi_value_site_pv"></span>
    </dd>
  </dt>
  <dt style="float:left;width:300px">
    <dd>
      <span style="float:left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>
      <span style="float:left">您是第</span>
      <span style="float:left" id="busuanzi_value_site_uv"></span>
      <span style="float:left">个小伙伴</span>
      <span>&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;</span>
      <span id="showDays"></span>
    </dd>
  </dt>
</dl>
</div>

<script>
  var birthDay = new Date('04/21/2018');
  var now = new Date();
  var duration = now.getTime() - birthDay.getTime();
  var total= Math.floor(duration / (1000 * 60 * 60 * 24));
  document.getElementById('showDays').innerHTML='本站已运行' + total + '天';
</script>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
